<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(2)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(2) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(2) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(2) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>CPU Scheduling | Dev Open Library</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="CPU Scheduling" /> <meta property="og:locale" content="en" /> <meta name="description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <meta property="og:description" content="A minimal, responsive and feature-rich Jekyll theme for technical writing." /> <link rel="canonical" href="http://localhost:4000/OS/os_cpu_scheduling.html" /> <meta property="og:url" content="http://localhost:4000/OS/os_cpu_scheduling.html" /> <meta property="og:site_name" content="Dev Open Library" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="CPU Scheduling" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A minimal, responsive and feature-rich Jekyll theme for technical writing.","headline":"CPU Scheduling","url":"http://localhost:4000/OS/os_cpu_scheduling.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Dev Open Library </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/Network/network_cors.html" class="nav-list-link">CORS</a></li><li class="nav-list-item"><a href="/OS/os_cpu_scheduling.html" class="nav-list-link">CPU Scheduling</a></li><li class="nav-list-item"><a href="/" class="nav-list-link">CS Study</a></li><li class="nav-list-item"><a href="/Web/web_csr_ssr.html" class="nav-list-link">CSR, SSR 의 등장 배경</a></li><li class="nav-list-item"><a href="/Web/web_csrf.html" class="nav-list-link">CSRF(Cross-site request forgery, 사이트 간 요청 위조)</a></li><li class="nav-list-item"><a href="/OS/os_com_and_operating_system.html" class="nav-list-link">Computer 구조</a></li><li class="nav-list-item"><a href="/Database/db_cache.html" class="nav-list-link">DB 캐싱</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dfs_bfs.html" class="nav-list-link">DFS와 BFS</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dp.html" class="nav-list-link">DP (Dynamic Programming)</a></li><li class="nav-list-item"><a href="/OS/os_deadlock.html" class="nav-list-link">Deadlock이란?</a></li><li class="nav-list-item"><a href="/Network/network_dns.html" class="nav-list-link">Domain</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_factory_pattern.html" class="nav-list-link">Factory Pattern</a></li><li class="nav-list-item"><a href="/Algorithm/ag_gcd_lcm.html" class="nav-list-link">GCD(Greatest Common Divisor) 알고리즘</a></li><li class="nav-list-item"><a href="/Web/graphql.html" class="nav-list-link">GraphQL</a></li><li class="nav-list-item"><a href="/Network/network_http_https.html" class="nav-list-link">HTTP (Hyper Text Transfer Protocol)</a></li><li class="nav-list-item"><a href="/Network/network_http_message.html" class="nav-list-link">HTTP 메시지</a></li><li class="nav-list-item"><a href="/Network/network_ip.html" class="nav-list-link">IP의 정의와 역할</a></li><li class="nav-list-item"><a href="/Database/db_index.html" class="nav-list-link">Index? 그게뭔데!</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_iterator_pattern.html" class="nav-list-link">Iterator pattern</a></li><li class="nav-list-item"><a href="/Web/web_jwt.html" class="nav-list-link">JWT</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_mvc_pattern.html" class="nav-list-link">MVC 패턴</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_mvp_pattern.html" class="nav-list-link">MVP Architecture Pattern</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_mvvm_pattern.html" class="nav-list-link">MVVM 패턴 정의</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_map.html" class="nav-list-link">Map</a></li><li class="nav-list-item"><a href="/OS/os_memory.html" class="nav-list-link">Memory</a></li><li class="nav-list-item"><a href="/OS/os_multi_processing.html" class="nav-list-link">Multi Process (멀티 프로세스)</a></li><li class="nav-list-item"><a href="/Network/network_devices.html" class="nav-list-link">Network Device</a></li><li class="nav-list-item"><a href="/Network/network_osi_tcpip.html" class="nav-list-link">OSI 7계층 &amp; TCP/IP 4계층</a></li><li class="nav-list-item"><a href="/OS/os_pcb_and_context_switch.html" class="nav-list-link">PCB와 Context Switching</a></li><li class="nav-list-item"><a href="/Database/db_query_optimization.html" class="nav-list-link">Query Optimization(Slow Query Tuning)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_quick_sort.html" class="nav-list-link">Quick Sort</a></li><li class="nav-list-item"><a href="/Web/restful_api.html" class="nav-list-link">RESTful API 설계 원칙과 네이밍 컨벤션</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_set.html" class="nav-list-link">Set</a></li><li class="nav-list-item"><a href="/OS/os_Blocking_Non-Blocking_Synchronous_Asynchronous.html" class="nav-list-link">Synchronous?</a></li><li class="nav-list-item"><a href="/Network/network_tcp.html" class="nav-list-link">TCP</a></li><li class="nav-list-item"><a href="/OS/os_thread.html" class="nav-list-link">Thread</a></li><li class="nav-list-item"><a href="/Network/network_udp.html" class="nav-list-link">UDP (User Datagram Protocol)</a></li><li class="nav-list-item"><a href="/OS/os_mutex_semaphore.html" class="nav-list-link">공유 자원 &amp; 임계 영역(Semaphore &amp; Mutex)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_implementation.html" class="nav-list-link">구현(Implementation)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_greedy.html" class="nav-list-link">그리디 (Greedy)</a></li><li class="nav-list-item"><a href="/Network/readme_NW.html" class="nav-list-link">네트워크</a></li><li class="nav-list-item"><a href="/Network/network_basic.html" class="nav-list-link">네트워크의 기초</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_revealing_module_pattern.html" class="nav-list-link">노출모듈 패턴 정의</a></li><li class="nav-list-item"><a href="/Algorithm/ag_dijkstra.html" class="nav-list-link">다익스트라(dijkstra) 알고리즘</a></li><li class="nav-list-item"><a href="/Database/db_migration.html" class="nav-list-link">데이터 마이그레이션 정리 노트</a></li><li class="nav-list-item"><a href="/Database/readme_DB.html" class="nav-list-link">데이터베이스</a></li><li class="nav-list-item"><a href="/Database/db_basic.html" class="nav-list-link">데이터베이스(Database) 기초</a></li><li class="nav-list-item"><a href="/Database/db_types_of_databases.html" class="nav-list-link">데이터베이스의 종류</a></li><li class="nav-list-item"><a href="/Design_Pattern/readme_DP.html" class="nav-list-link">디자인패턴</a></li><li class="nav-list-item"><a href="/Network/network_load_balancing.html" class="nav-list-link">로드 밸런싱이란?</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_array_vector.html" class="nav-list-link">배열(Array)</a></li><li class="nav-list-item"><a href="/Database/db_backup_recovery.html" class="nav-list-link">백업(Backup)과 복구(Recovery)</a></li><li class="nav-list-item"><a href="/Database/db_distributed_database.html" class="nav-list-link">분산형 데이터베이스</a></li><li class="nav-list-item"><a href="/Algorithm/ag_divide_and_conquer.html" class="nav-list-link">분할 정복 알고리즘</a></li><li class="nav-list-item"><a href="/Algorithm/ag_bitMask.html" class="nav-list-link">비트마스크</a></li><li class="nav-list-item"><a href="/Algorithm/ag_permutation_combination.html" class="nav-list-link">순열 &amp; 조합</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_stack_queue.html" class="nav-list-link">스택 &amp; 큐</a></li><li class="nav-list-item"><a href="/Algorithm/ag_stack_queue.html" class="nav-list-link">스택 &amp; 큐</a></li><li class="nav-list-item"><a href="/Database/db_explain.html" class="nav-list-link">실행 계획(EXPLAIN) 분석</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_singleton_pattern.html" class="nav-list-link">싱글톤 패턴</a></li><li class="nav-list-item"><a href="/Algorithm/readme_AG.html" class="nav-list-link">알고리즘</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_Time_Space%20Complexity.html" class="nav-list-link">알고리즘의 성능 분석: Big-O 표기법과 복잡도 이해하기</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_linked_list.html" class="nav-list-link">연결 리스트 (Linked List)</a></li><li class="nav-list-item"><a href="/OS/readme_OS.html" class="nav-list-link">운영체제</a></li><li class="nav-list-item"><a href="/Web/readme_Web.html" class="nav-list-link">웹</a></li><li class="nav-list-item"><a href="/Network/network_web_server.html" class="nav-list-link">웹 서버</a></li><li class="nav-list-item"><a href="/Database/db_event_sourcing_cqrs.html" class="nav-list-link">이벤트 소싱(Event Sourcing)과 CQRS(Command Query Responsibillity Segregation)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_binary_search.html" class="nav-list-link">이분 탐색 (Binary Search)</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_binary_tree.html" class="nav-list-link">이진 트리, 이진 탐색 트리</a></li><li class="nav-list-item"><a href="/Data_Structure/readme_DS.html" class="nav-list-link">자료구조</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_strategy_pattern.html" class="nav-list-link">전략패턴(Strategy Pattern) 개요</a></li><li class="nav-list-item"><a href="/Database/db_normal_forms.html" class="nav-list-link">정규화</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_observer_pattern.html" class="nav-list-link">정의</a></li><li class="nav-list-item"><a href="/Database/db_join.html" class="nav-list-link">조인(JOIN)</a></li><li class="nav-list-item"><a href="/Network/cookie_and_session.html" class="nav-list-link">쿠키 &amp; 세션</a></li><li class="nav-list-item"><a href="/Database/db_transaction.html" class="nav-list-link">트랜잭션(Transaction)</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_tree_graph.html" class="nav-list-link">트리와 그래프의 공통점</a></li><li class="nav-list-item"><a href="/Database/db_partitioning_sharding.html" class="nav-list-link">파티셔닝 (Partitioning)</a></li><li class="nav-list-item"><a href="/OS/os_process.html" class="nav-list-link">프로세스(Process)란?</a></li><li class="nav-list-item"><a href="/Design_Pattern/dp_proxy_pattern.html" class="nav-list-link">프록시 패턴 (Proxy Pattern)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_merge_sort.html" class="nav-list-link">합병 정렬(Merge Sort)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_hashing.html" class="nav-list-link">해싱(Hashing)이란?</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_hash_table.html" class="nav-list-link">해싱, 해시 함수 란?</a></li><li class="nav-list-item"><a href="/Algorithm/ag_heap.html" class="nav-list-link">힙(Heap)</a></li><li class="nav-list-item"><a href="/Data_Structure/ds_heap_priority_queue.html" class="nav-list-link">힙(Heap)</a></li><li class="nav-list-item"><a href="/Algorithm/ag_heap_sort.html" class="nav-list-link">힙(Heap)이란, 어떤 자료구조일까?</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Dev Open Library" aria-label="Search Dev Open Library" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="cpu-scheduling"> <a href="#cpu-scheduling" class="anchor-heading" aria-labelledby="cpu-scheduling"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> CPU Scheduling </h1> <h2 id="cpu-스케줄링"> <a href="#cpu-스케줄링" class="anchor-heading" aria-labelledby="cpu-스케줄링"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> CPU 스케줄링 </h2> <p><strong>정의</strong>: 여러 프로세스가 CPU를 공유하는 환경에서, 효율적으로 CPU를 배분하여 시스템 성능을 최적화하고 처리 효율을 극대화하는 메커니즘.</p> <p><strong>목적</strong>: 시스템 성능 최적화 및 처리 효율 극대화.  → CPU 이용률 최대화.</p> <p>컴퓨터 시스템에서는 여러 프로세스가 동시에 실행되므로 CPU 자원을 효율적으로 관리하는 것이 중요하다.운영체제는 프로세스가 상황/중요도에 맞게 CPU를 이용할 수 있도록 <strong>프로세스 우선순위(priority)</strong> 를 부여한다.</p> <h3 id="스케줄링-큐"> <a href="#스케줄링-큐" class="anchor-heading" aria-labelledby="스케줄링-큐"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>스케줄링 큐</strong> </h3> <ul> <li>프로세스들이 서는 줄</li> <li>스케줄링에서의 큐는 반드시 선입선출 방식일 필요는 없다.</li> <li> <p>같은 큐 내에서도 우선순위 별로 처리가 된다.</p> </li> <li>준비 큐 : CPU를 이용하고 싶어하는 프로세스들이 서는 줄</li> <li>대기 큐 : 입출력장치들을 이용하고 싶어하는 프로세스들이 서는 줄</li> </ul> <p><img src="/OS/img/os_cpu_scheduling_1.png" alt="" /></p> <h2 id="주요-용어"> <a href="#주요-용어" class="anchor-heading" aria-labelledby="주요-용어"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 주요 용어 </h2> <ul> <li><strong>도착 시간:</strong> 프로세스가 준비 큐에 도착하는 시간.</li> <li><strong>완료 시간:</strong> 프로세스가 실행을 완료하는 시간.</li> <li><strong>버스트 시간(Burst Time)</strong>: 프로세스가 CPU를 사용하는 시간.</li> <li><strong>대기 시간(Waiting Time)</strong>: 프로세스가 CPU 할당을 기다린 시간.</li> <li><strong>턴어라운드 시간(Turnaround Time)</strong>: 프로세스 제출부터 완료까지의 시간.</li> </ul> <h2 id="cpu-스케줄링-알고리즘"> <a href="#cpu-스케줄링-알고리즘" class="anchor-heading" aria-labelledby="cpu-스케줄링-알고리즘"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>CPU 스케줄링 알고리즘</strong> </h2> <p><img src="/OS/img/os_cpu_scheduling_2.png" alt="" /></p> <div class="table-wrapper"><table> <thead> <tr> <th>분류</th> <th>설명</th> <th>장점</th> <th>단점</th> </tr> </thead> <tbody> <tr> <td>선점형</td> <td>CPU를 강제로 뺏을 수 있는 방식. 프로세스가 중단될 수 있음.</td> <td>자원 독점 방지, 모든 프로세스에 골고루 자원을 배분</td> <td>문맥 교환에 오버헤드 발생, 비효율적인 자원 분배 가능</td> </tr> <tr> <td>비선점형</td> <td>CPU를 할당받은 프로세스가 종료될 때까지 다른 프로세스가 개입할 수 없음.</td> <td>문맥 교환 오버헤드 적음</td> <td>자원 독점 가능, 긴 프로세스가 시스템을 지배할 수 있음</td> </tr> </tbody> </table></div> <h2 id="비선점형non-preemptive"> <a href="#비선점형non-preemptive" class="anchor-heading" aria-labelledby="비선점형non-preemptive"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 비선점형(Non-preemptive) </h2> <h3 id="fcfs-first-come-first-served"> <a href="#fcfs-first-come-first-served" class="anchor-heading" aria-labelledby="fcfs-first-come-first-served"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>FCFS (First-Come, First-Served)</strong> </h3> <ul> <li>선입 선처리 스케줄링</li> <li>단순히 준비큐에 <strong>삽입된 순서대로 처리</strong>하는 비선점 스케줄링</li> <li>먼저 CPU를 요청한 프로세스부터 CPU 할당</li> <li>단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있다.(Convoy Effect, 호위 효과)</li> </ul> <p><strong>예제</strong></p> <p>다음과 같은 작업들이 있을 때:</p> <ol> <li>P1 (실행 시간: 6ms)</li> <li>P2 (실행 시간: 8ms)</li> <li>P3 (실행 시간: 2ms)</li> </ol> <div class="table-wrapper"><table> <thead> <tr> <th>프로세스</th> <th>실행 시간(Burst Time)</th> <th>대기 시간(Waiting Time)</th> <th>완료 시간(Turnaround Time)</th> </tr> </thead> <tbody> <tr> <td>P1</td> <td>6ms</td> <td>0ms</td> <td>6ms</td> </tr> <tr> <td>P2</td> <td>8ms</td> <td>6ms</td> <td>14ms</td> </tr> <tr> <td>P3</td> <td>2ms</td> <td>14ms</td> <td>16ms</td> </tr> </tbody> </table></div> <p>도착 순서: P1 → P2 → P3</p> <p>실행 순서: P1 → P2 → P3</p> <p>평균 대기 시간 = (0 + 6 + 14) / 3 = 6.67ms 평균 완료 시간 = (6 + 14 + 16) / 3 = 12ms</p> <p><strong>FCFS</strong>에서는 P1 → P2 → P3 순서로 실행되므로, B와 C는 A가 끝날 때까지 대기해야 한다. 짧은 작업이 먼저 끝날 수 있지만, 긴 작업이 CPU를 점유하여 시스템 효율성이 떨어진다.</p> <p>해결 방법으로 <strong>SJF</strong>, <strong>RR</strong>, <strong>Priority Scheduling</strong>과 같은 스케줄링 기법이 있다.</p> <h3 id="sjf-shortest-job-first"> <a href="#sjf-shortest-job-first" class="anchor-heading" aria-labelledby="sjf-shortest-job-first"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SJF (Shortest Job First) </h3> <ul> <li>CPU 사용 시간이 가장 짧은 프로세스부터 처리</li> <li>장점 <ul> <li>평균 대기 시간 최소화.</li> <li>호위 효과 방지.</li> </ul> </li> <li>단점: 긴 작업은 무한정 대기할 가능성이 있다. (Starvation, 기아 상태)</li> </ul> <p><strong>예제</strong></p> <p>다음과 같은 작업들이 있을 때:</p> <ol> <li>P1 (실행 시간: 6ms)</li> <li>P2 (실행 시간: 8ms)</li> <li>P3 (실행 시간: 2ms)</li> </ol> <div class="table-wrapper"><table> <thead> <tr> <th>프로세스</th> <th>실행 시간(Burst Time)</th> <th>대기 시간(Waiting Time)</th> <th>완료 시간(Turnaround Time)</th> </tr> </thead> <tbody> <tr> <td>P1</td> <td>6ms</td> <td>2ms</td> <td>8ms</td> </tr> <tr> <td>P2</td> <td>8ms</td> <td>8ms</td> <td>16ms</td> </tr> <tr> <td>P3</td> <td>2ms</td> <td>0ms</td> <td>2ms</td> </tr> </tbody> </table></div> <p>도착 순서: P1 → P2 → P3</p> <p>실행 순서: P3 → P1 → P2</p> <p>평균 대기 시간 = (0 + 2 + 8) / 3 = 3.33ms 평균 완료 시간 = (2 + 8 + 16) / 3 = 8.67ms</p> <h2 id="선점형preemptive"> <a href="#선점형preemptive" class="anchor-heading" aria-labelledby="선점형preemptive"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 선점형(Preemptive) </h2> <h3 id="rr-round-robin"> <a href="#rr-round-robin" class="anchor-heading" aria-labelledby="rr-round-robin"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> RR (Round Robin) </h3> <ul> <li>일정 시간(Time Quantum) 동안 프로세스를 실행한 후 대기열의 끝으로 이동한다.</li> <li>선입 선처리 스케줄링 + 시간 퀸텀(Time Quantum) <ul> <li>시간 퀸텀 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간</li> </ul> </li> <li>장점: 응답 시간이 일정.</li> <li>단점: 프로세스 실행 시간(Time Quantum) 설정이 성능에 영향을 준다. <ul> <li>프로세스 실행 시간이 극단적으로 커지면 FCFS과 같이 호위 효과가 발생할 수 있다.</li> <li>프로세스 실행 시간이 지나치게 작으면 문맥교환에 발생하는 오버헤드가 발생한다.</li> </ul> </li> </ul> <p><strong>예제</strong></p> <p><img src="/OS/img/os_cpu_scheduling_3.png" alt="" /> Time Quantum = 5ms</p> <p>| 프로세스 | 실행 시간(Burst Time) | 대기 시간(Waiting Time) | 완료 시간(Turnaround Time) | | — | — | — | — | | P1 | 20ms | 15ms | 35ms | | P2 | 3ms | 5ms | 8ms | | P3 | 7ms | 18ms | 25ms | | P4 | 5ms | 13ms | 18ms |</p> <ol> <li>0ms: P1 실행</li> <li>5ms: P2 실행, P1 대기 (남은 시간 15ms)</li> <li>8ms: P2 완료, P3 실행</li> <li>13ms: P4 실행, P3 대기(남은 시간 2ms)</li> <li>18ms: P4 완료, P1 실행</li> <li>23ms: P3 실행 P1 대기 (남은 시간 10ms)</li> <li>25ms: P3 완료, P1 실행</li> <li>35ms: P1 완료</li> </ol> <p><strong>결과</strong></p> <p>평균 대기 시간 = (15+5+18+13)/4=12.75ms</p> <p>평균 완료 시간 = (35+8+25+18)/4=21.5ms</p> <h3 id="srtf-shortest-remaining-time-first"> <a href="#srtf-shortest-remaining-time-first" class="anchor-heading" aria-labelledby="srtf-shortest-remaining-time-first"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> SRTF (Shortest Remaining Time First) </h3> <ul> <li>남은 실행 시간이 가장 짧은 프로세스를 우선 실행한다.</li> <li>정해진 시간만큼 CPU를 이용하고, 다음으로 CPU를 사용할 프로세스는 남은 작업 시간이 가장 적은 프로세스로 선택한다.</li> <li>최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링</li> <li>장점: 짧은 작업 우선 처리로 평균 대기 시간 감소.</li> <li>단점: 긴 작업은 계속 대기할 가능성 있음.</li> </ul> <p><strong>예제</strong></p> <p><img src="/OS/img/os_cpu_scheduling_4.png" alt="" /></p> <p>Time Quantum = 5ms</p> <p>| 프로세스 | 실행 시간(Burst Time) | 대기 시간(Waiting Time) | 완료 시간(Turnaround Time) | | — | — | — | — | | P1 | 20ms | 15ms | 35ms | | P2 | 3ms | 0ms | 3ms | | P3 | 7ms | 7ms | 20ms | | P4 | 5ms | 3ms | 8ms |</p> <ol> <li>0ms: P2 실행</li> <li>3ms: P2 완료, P4 실행</li> <li>8ms: P4 완료, P3 실행</li> <li>13ms: P3 대기(남은 시간 2ms), P1 실행</li> <li>18ms: P1 대기, P3 실행</li> <li>20ms: P3 완료, P1 실행</li> <li>35ms: P1 완료</li> </ol> <p><strong>결과</strong></p> <p>평균 대기 시간 = (15+0+7+3)/4=6.25ms</p> <p>평균 완료 시간 = (35+3+20+8)/4=16.5ms</p> <h3 id="priority-scheduling"> <a href="#priority-scheduling" class="anchor-heading" aria-labelledby="priority-scheduling"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Priority Scheduling </h3> <ul> <li>프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행한다.</li> <li>동일한 우선순위를 가진 프로세스가 여러 개 있을 경우, 일반적으로 FCFS (First Come First Serve) 방식으로 실행된다.</li> <li>장점: 중요 작업 우선 처리 가능.</li> <li>단점: 낮은 우선순위 작업의 기아 현상(Starvation).</li> </ul> <p><strong>Aging 기법</strong>(시간이 지남에 따라 우선순위 증가).</p> <p>오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식으로 대기 중인 프로세스의 우선순위를 점진적으로 증가시킨다. 우선순위가 낮아도 언젠가는 우선순위가 높아진다.</p> <p><strong>장점</strong></p> <ul> <li>기아 현상을 방지.</li> <li>우선순위가 낮은 프로세스도 결국 CPU를 사용할 수 있도록 보장.</li> </ul> <p><strong>단점</strong></p> <ul> <li>오버헤드: 우선순위를 조정하는 데 추가적인 계산이 필요</li> <li>우선순위 상승으로 인해 예기치 않은 실행 순서가 발생할 수 있음.</li> </ul> <h3 id="다단계-큐-스케줄링-multilevel-queue"> <a href="#다단계-큐-스케줄링-multilevel-queue" class="anchor-heading" aria-labelledby="다단계-큐-스케줄링-multilevel-queue"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다단계 큐 스케줄링 (Multilevel queue) </h3> <p><img src="/OS/img/os_cpu_scheduling_5.png" alt="" /></p> <ul> <li>우선순위 스케줄링의 발전된 형태로 우선순위별로 준비 큐를 여러 개 사용한다.</li> <li>우선 순위가 가장 높은 큐에 있는 프로세스를 먼저 처리한다.</li> <li>장점 <ul> <li>프로세스 유형별로 우선순위를 구분하기 쉽다.</li> <li>상황에 맞는 스케줄링 알고리즘을 적용할 수 있다.</li> </ul> </li> <li>단점: 우선순위 간 이동이 불가능 하기 때문에 우선순위가 낮은 프로세스는 계속해서 대기하는 기아 현상이 발생할 수 있다.</li> </ul> <h3 id="다단계-피드백-큐-스케줄링-multilevel-feedback-queue"> <a href="#다단계-피드백-큐-스케줄링-multilevel-feedback-queue" class="anchor-heading" aria-labelledby="다단계-피드백-큐-스케줄링-multilevel-feedback-queue"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 다단계 피드백 큐 스케줄링 (Multilevel feedback queue) </h3> <ul> <li>다단계 큐 스케줄링의 단점을 보완한 알고리즘으로 큐 간 이동을 허용한다.</li> <li>CPU 스케줄링 방식의 가장 일반적인 형태</li> <li>동작 원리 <ol> <li>높은 우선순위 큐에서 프로세스를 먼저 처리.</li> <li>일정 시간 동안 실행 후 시간 초과하면 하위 큐로 이동.</li> <li>하위 큐에서 대기 시간이 길어지면 다시 상위 큐로 이동</li> </ol> </li> </ul> <p><a href="https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html">https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html</a></p> <p>https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/</p> <p>https://www.robotstory.co.kr/raspberry/?vid=148</p> <p>https://www.youtube.com/watch?v=CdrozYcVccE</p> <p>https://www.youtube.com/watch?v=w1z6WCyMdhQ</p> <p><strong>추가</strong></p> <h2 id="cfs-completely-fair-scheduler"> <a href="#cfs-completely-fair-scheduler" class="anchor-heading" aria-labelledby="cfs-completely-fair-scheduler"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>CFS (Completely Fair Scheduler )</strong> </h2> <ul> <li>모든 프로세스가 CPU 자원을 공평하게 사용할 수 있도록 보장하는 스케줄러</li> <li>가상 런타임(Virtual Runtime) <ul> <li>각 프로세스가 CPU를 사용한 시간을 기록한 값</li> <li>CPU를 가장 적게 사용한 프로세스가 가장 먼저 실행된다.</li> <li>CPU 사용 시간이 많을수록 가상 런타임 값이 더 빨리 증가한다.</li> </ul> </li> <li>레드-블랙 트리(Red-Black Tree) <ul> <li>레드-블랙 트리라는 자료구조를 사용해 프로세스를 관리하며, 프로세스가 CPU를 사용한 시간에 따라 정렬한다.</li> </ul> </li> </ul> <h3 id="특징"> <a href="#특징" class="anchor-heading" aria-labelledby="특징"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>특징</strong> </h3> <ol> <li><strong>공정성 보장</strong> <ul> <li>CPU 사용량이 적은 프로세스가 더 자주 실행된다.</li> <li>우선순위가 높은 프로세스는 가상 런타임 증가 속도가 느려져 더 많은 CPU 시간을 할당받는다.</li> </ul> </li> <li><strong>레드-블랙 트리 사용</strong> <ul> <li>모든 실행 가능한 프로세스를 가상 런타임을 기준으로 정렬하여 관리한다.</li> <li>가장 가상 런타임이 작은 프로세스가 트리의 왼쪽 끝에 위치하고 먼저 실행된다.</li> </ul> <p><img src="/OS/img/os_cpu_scheduling_6.png" alt="" /></p> </li> </ol> <h3 id="cfs의-동작-방식"> <a href="#cfs의-동작-방식" class="anchor-heading" aria-labelledby="cfs의-동작-방식"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>CFS의 동작 방식</strong> </h3> <ol> <li><strong>프로세스 삽입</strong> <ul> <li>새 프로세스가 실행 준비 상태(Ready)에 들어오면, 레드-블랙 트리에 삽입된다.</li> </ul> </li> <li><strong>최소 가상 런타임 선택</strong> <ul> <li>레드-블랙 트리에서 가장 <strong>가상 런타임 값이 작은 프로세스</strong>를 선택하여 실행한다.</li> </ul> </li> <li><strong>실행 및 가상 런타임 업데이트</strong> <ul> <li>프로세스가 실행되면 해당 프로세스의 가상 런타임 값이 증가한다.</li> <li>실행이 끝난 후, 프로세스는 다시 레드-블랙 트리에 삽입된다.</li> </ul> </li> </ol> <h3 id="장점"> <a href="#장점" class="anchor-heading" aria-labelledby="장점"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 장점 </h3> <ol> <li><strong>공정성:</strong> 모든 프로세스가 CPU를 공평하게 사용할 수 있다.</li> <li><strong>효율성</strong>: 레드-블랙 트리를 사용해 스케줄링 작업을 효율적으로 수행한다. O(log N)</li> <li><strong>우선순위 조정 가능:</strong> Nice 값을 통해 우선순위를 조정하여 특정 프로세스에 더 많은 CPU 시간을 할당할 수 있다. <ul> <li>Nice 값: 프로세스의 우선순위(priority)를 조정하는 값</li> </ul> </li> <li><strong>다양한 환경 지원</strong></li> </ol> <h3 id="리눅스에서-cfs를-사용하는-이유"> <a href="#리눅스에서-cfs를-사용하는-이유" class="anchor-heading" aria-labelledby="리눅스에서-cfs를-사용하는-이유"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> <strong>리눅스에서 CFS를 사용하는 이유</strong> </h3> <p><strong>공정성, 성능, 확장성, 다양한 워크로드 처리</strong> 등을 모두 만족시키기 위함.</p> <p><strong>기존 스케줄러의 문제점</strong></p> <ol> <li>과거 리눅스는 우선순위 기반의 타임 슬라이스 방식을 사용했는데, 특정 프로세스가 불공정하게 자원을 독점하는 문제가 있었다. <ul> <li>👉 Nice 값으로 우선순위 조정</li> </ul> </li> <li>GUI 프로그램(인터랙티브 프로그램)이나 I/O 중심의 프로세스는 응답 시간이 매우 중요하지만, 기존 스케줄러는 CPU 중심 프로세스에 우선순위를 주어 지연(latency)이 발생했다.</li> <li>특정 환경에 최적화된 스케줄러는 다른 환경에서는 비효율적일 수 있다. <ul> <li>예를 들어, I/O 중심 프로세스와 CPU 중심 프로세스가 섞인 경우 효율적으로 처리하지 못한다.</li> </ul> </li> <li>프로세스 수가 많아지면 성능이 급격히 저하되거나 관리 오버헤드가 증가 했다. <ul> <li>👉 레드-블랙 트리(Red-Black Tree) 구조로 성능 보장</li> </ul> </li> </ol> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
