# 프로세스(Process)란?

## 프로그램 vs 프로세스

`프로그램` 자체로는 아무 일도 할 수 없다. 프로그램은 그저 **하드디스크에 저장되어 있는 하나의 파일**이다. 프로그램이 사용자에게 기능을 제공하기 위해서는, 메모리에 로드되어 프로그램 카운터(PC) 및 관련 자원의 집합을 가진 능동적인 존재로서 동작해야 한다.

`프로세스`는 **실행 중인 프로그램**을 의미한다. 프로세스는 **OS에 의해 관리**되며, 독립적으로 실행되고 자원을 할당 받을 수 있는 단위이다. OS는 프로세스들에게 적절히 자원을 분배하여 여러가지 작업을 수행할 수 있게 한다.

프로그램이 프로세스가 되는 과정

1. 사용자가 프로그램을 시작하라는 요청(아이콘을 더블클릭 하는 등)을 보냄
2. OS는 하드 디스크에서 해당 프로그램을 메인 메모리로 로드하면서 필요한 자원을 할당한다. 

## 프로세스 구조

메모리 상에 존재하는 프로세스는 아래와 같은 구조를 가진다. 

`Code와 Data` 영역의 **크기는 고정**되어 있지만, `Heap과 Stack`의 영역은 **런타임에 수시로 변경**된다.

|  | 정의 / 특징 | 저장되는 요소 |
| --- | --- | --- |
| **Code** | 실행 가능한 코드 집합. 코드는 컴파일 되어 0과 1로 변환된 기계어가 저장됨 |  |
| **Data** | 프로그램 시작시 초기화. 프로세스가 종료될 때까지 유지됨 | 전역 변수, 정적 변수, 상수 등 |
| **Heap** | 런타임에 동적으로 메모리에 할당되는 데이터 | 실행 중에 생성되는 인스턴스에 대한 정보 |
| **Stack** | 함수가 호출되면 stack 공간이 생성. 함수가 종료되면 제거됨 | 지역 변수, 매개 변수, return 주소 등 |

![](/OS/img/os_process_1.png)


## 프로세스 상태

프로세스의 상태에는 5가지가 있다.

| **상태**          | **설명**                                                                                                                                       |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| **생성 (new)**     | 프로세스가 생성된 상태. OS의 커널에 PCB 등 생성. 아직 실행되기 위한 자원을 할당 받지 못한 상태                                                |
| **준비 (ready)**   | 프로세스가 실행을 기다리는 상태. 프로세스가 필요한 자원은 모두 할당 받았지만, CPU를 할당 받지 못한 상태. CPU의 서비스를 받기 위해 Ready Queue에서 대기하고 있는 상태 |
| **실행 (running)** | 프로세스가 CPU를 할당 받아 실제로 코드를 실행하는 상태                                                                                       |
| **대기 (waiting, blocked)** | I/O나 다른 event를 기다리며 프로세스가 멈춰있는 상태. 특정 자원을 사용할 수 있을 때까지 실행을 멈추고, 다시 Ready Queue로 들어감                    |
| **종료 (terminated)** | 프로세스의 실행이 완료되어 종료된 상태. 할당된 자원이 해제되고, 프로세스의 메모리 공간은 OS에 반환됨                                            |

프로세스 전이도
![](/OS/img/os_process_2.png)


## **PCB(Process Control Block)**

PCB란 **OS가 프로세스를 관리하기 위해 사용하는 데이터 구조**다. 각 프로세스는 하나의 PCB를 가지며, PCB에는 해당 프로세스에 대한 모든 정보가 있다. 프로세스가 생성되면 운영체제는 PCB를 할당하고, 프로세스가 종료되면 해당 PCB를 해제한다.

#### PCB에 저장되는 정보

1. 프로세스 식별자(PID)
    - 프로세스를 구별하는 유일한 식별자
2. 프로세스 상태
    - 프로세스의 현재 상태
    - 실행, 준비, 대기 등
3. 프로세스 카운터(PC)
    - 프로세스가 다음에 실행할 명령어(코드)의 주소를 가리키는 포인터
4. 레지스터
    - 프로세스가 현재 실행되는 동안 사용되는 레지스터 값들을 저장
    - 프로세스가 일시 중단되고 다시 실행 될 때 레지스터 값들을 복원하는 데 사용
5. 스케줄링 정보
    - 프로세스의 우선순위, 할당 된 CPU 시간, 스케줄링 알고리즘과 관련된 정보 등 스케줄링에 필요한 정보
6. 메모리 관리 정보
    - 프로세스가 사용하는 메모리 공간의 주소 범위, 페이지 테이블, 메모리 할당 정보 등과 같이 메모리 관리에 필요한 정보를 저장
7. 입출력 상태
    - 프로세스가 현재 사용 중인 입출력 장치와 관련된 정보

## 프로세스 레지스터

컴퓨터에서는 프로세스를 처리하기 위한 두 개의 레지스터가 있다. 

PC(Program Counter)와 SP(Stack Pointer)이며, 프로세스의 실행 및 메모리 관리와 관련된 역할을 한다.

### PC **(Program Counter)**

**실행할 명령어의 주소를 가리키는 레지스터**다. 코드를 실행하면 코드가 한 줄씩 내려가며 실행된다. 프로세스는 한 줄을 처리한 뒤 다음에 실행할 코드가 어디인지 알려줘야 실행할 수 있다. 이때, 다음 실행할 코드의 주소를 저장하는 레지스터인 PC가 필요하다. 프로세스는 명령어를 순차적으로 실행하면서 PC 값을 증가시켜 다음에 실행할 명령어를 가리킨다.

따라서 PC는 **프로그램의 흐름을 제어**하는 역할을 한다. 프로세스가 명령어를 실행하다가 분기나 점프 명령어를 만나면, PC의 값을 분기된 주소로 변경하여 해당 명령어를 실행한다. PC는 프로세스가 중단되거나 인터럽트(예외 상황)가 발생했을 때, 현재 실행 중이던 명령어의 주소를 저장하고, 이후 다시 프로세스가 실행되었을 때 주소를 찾아가 **재실행** 시킬 수 있는 역할을 한다.

### SP **(Stack Pointer)**

SP는 **현재 실행 중인 프로세스의 스택(Stack)의 최상단을 가리키는 레지스터**다. 즉, SP는 스택 프레임(Stack Frame)의 시작 주소를 가리키며, 스택에 데이터를 저장하거나 불러올 때 사용된다. 함수 호출 시에는 SP가 감소하여 스택에 새로운 스택 프레임(스택 공간)을 생성하고, 함수가 반환되면 SP가 증가하여 이전 스택 프레임으로 돌아간다. SP는 **프로세스의 스택 영역을 관리**하고, Stack Overflow와 같은 문제를 방지하기 위해 **제한된 메모리 영역을 사용**하는 등의 역할을 수행한다.

예를 들어, 재귀함수의 경우, 가장 최근에 호출한 함수 순서대로 Stack에 쌓인다. **가장 최근에 호출된 함수**(최상단 함수)의 위치를 알고 있으면, 어디까지 함수가 호출되어 있는지 프로세스가 알 수 있다.

# 출처
[https://medium.com/ioxio/study-os-2-process-update-중-c6fe324329be](https://medium.com/ioxio/study-os-2-process-update-%EC%A4%91-c6fe324329be)

https://itwiki.kr/w/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C#google_vignette
